<?php
/**
 * ||GEISSWEB| EU VAT Enhanced
 *
 * NOTICE OF LICENSE
 *
 * This source file is subject to the GEISSWEB End User License Agreement
 * that is available through the world-wide-web at this URL: https://www.geissweb.de/legal-information/eula
 *
 * DISCLAIMER
 *
 * Do not edit this file if you wish to update the extension in the future. If you wish to customize the extension
 * for your needs please refer to our support for more information.
 *
 * @copyright   Copyright (c) 2015 GEISS WeblÃ¶sungen (https://www.geissweb.de)
 * @license     https://www.geissweb.de/legal-information/eula GEISSWEB End User License Agreement
 */

namespace Geissweb\Euvat\Helper;

use Geissweb\Euvat\Api\Data\ValidationInterface;
use Geissweb\Euvat\Api\Data\ValidationResultInterface;
use Geissweb\Euvat\Logger\Logger;
use Geissweb\Euvat\Validator\Syntax;
use Geissweb\Euvat\Model\ValidationRepository;
use Magento\Customer\Api\Data\AddressInterface;
use Magento\Customer\Model\Address as CustomerModelAddress;
use Magento\Framework\Intl\DateTimeFactory;
use Magento\Sales\Api\Data\OrderAddressInterface;

/**
 * Class Functions provides some helper functions
 */
class Functions
{
    /**
     * @var Configuration
     */
    public $configHelper;

    /**
     * @var Logger
     */
    public $logger;

    /**
     * @var ValidationRepository
     */
    public $validationRepository;

    /**
     * @var DateTimeFactory
     */
    public $dateTimeFactory;

    /**
     * @var Syntax
     */
    public $syntaxValidator;

    /**
     * Configuration constructor.
     *
     * @param Configuration        $configHelper
     * @param Logger               $logger
     * @param ValidationRepository $validationRepository
     * @param Syntax               $syntaxValidator
     * @param DateTimeFactory      $dateTimeFactory
     */
    public function __construct(
        Configuration $configHelper,
        Logger $logger,
        ValidationRepository $validationRepository,
        Syntax $syntaxValidator,
        DateTimeFactory $dateTimeFactory
    ) {
        $this->configHelper = $configHelper;
        $this->logger = $logger;
        $this->validationRepository = $validationRepository;
        $this->dateTimeFactory = $dateTimeFactory;
        $this->syntaxValidator = $syntaxValidator;
    }

    /**
     * Estimates if we can reuse a existing validation
     *
     * @param string $vatNumber
     *
     * @return bool
     */
    public function getNeedToValidate(string $vatNumber): bool
    {
        $needToValidate = true;
        $existingValidation = $this->getValidationData($vatNumber);
        if ($existingValidation instanceof ValidationInterface) {
            if ($this->configHelper->isPeriodicRevalidationEnabled()) {
                //Estimate if we can reuse the existing validation
                if ($existingValidation->getVatRequestSuccess()) {
                    $period = $this->configHelper->getRevalidationPeriod() * 30;
                    $validationDate = $this->dateTimeFactory->create($existingValidation->getVatRequestDate());
                    $now = $this->dateTimeFactory->create('now');
                    $daysSinceLast = $validationDate->diff($now)->days;
                    if ($daysSinceLast < $period) {
                        $needToValidate = false;
                        $this->logger->customLog("[getNeedToValidate] got existing entry which is usable
                        ($daysSinceLast days since last validation).");
                    }
                }
            }
            if ($existingValidation->getVatRequestId() === 'OFFLINE'
                || $existingValidation->getVatRequestId() === 'INIT'
            ) {
                $needToValidate = true;
            }
        }
        $this->logger->customLog("[getNeedToValidate] $vatNumber: ".(int)$needToValidate);
        return $needToValidate;
    }

    /**
     * Read from repository
     *
     * @param string $vatNumber
     *
     * @return \Geissweb\Euvat\Api\Data\ValidationInterface|bool
     */
    public function getValidationData(string $vatNumber)
    {
        return $this->validationRepository->getByVatId($vatNumber);
    }

    /**
     * Gives the VAT based on address
     *
     * @param $order
     * @param string $vatBasedOn
     *
     * @return object|bool
     */
    public function getBasedOnAddressFromOrder($order, string $vatBasedOn)
    {
        foreach ($order->getAddresses() as $address) {
            if ($address->getAddressType() == $vatBasedOn) {
                return $address;
            }
        }

        foreach ($order->getAddresses() as $address) {
            if ($address->getAddressType() == 'billing') {
                return $address;
            }
        }
        return false;
    }

    /**
     * Return customer group id according the conditions
     *
     * @param AddressInterface|OrderAddressInterface|CustomerModelAddress $address
     * @param ValidationInterface|ValidationResultInterface $vatValidation
     * @return int
     */
    public function getCustomerGroup($address, $vatValidation) : int
    {
        $this->logger->customLog("[FunctionsHelper::Group Assignment]");
        try {
            if (!is_object($vatValidation)) {
                if (is_object($address) && !$this->configHelper->isEuCountry($address->getCountryId())) {
                    $this->logger->customLog("NON-Europe Group.");
                    return $this->configHelper->getTargetGroupOutsideEu();
                }
                return $this->configHelper->getTargetGroupDefault();
            }

            $vatdata = [
                'address_country_id' => $address->getCountryId(),
                'vat_country_id' => $vatValidation->getVatRequestCountryCode(),
                'vat_id' => $vatValidation->getVatId(),
                'vat_is_valid' => $vatValidation->getVatIsValid(),
                'vat_request_success' => $vatValidation->getVatRequestSuccess()
            ];
            $shopCc = $this->configHelper->getMerchantCountryCode();

            if (isset($vatdata['address_country_id']) && !empty($vatdata['address_country_id'])) {
                $customerCc = $vatdata['address_country_id'];
            } elseif (isset($vatdata['vat_country_id']) && !empty($vatdata['vat_country_id'])) {
                $customerCc = $vatdata['vat_country_id'];
            } else {
                $this->logger->customLog("Default Group.");
                return $this->configHelper->getTargetGroupDefault();
            }

            // Fix Greece and Northern Ireland
            if ($customerCc == "EL") {
                $customerCc = "GR";
            }
            if ($customerCc == "XI") {
                $customerCc = "GB";
            }

            // Check the validation data and return best fitting group
            if (isset($vatdata['vat_id']) && !empty($vatdata['vat_id'])) {
                $this->logger->customLog("Customer CC: $customerCc | VAT Number: " . $vatdata['vat_id']);

                // Valid EU
                if ($vatdata['vat_is_valid'] == true
                    && $vatdata['vat_request_success'] == true
                    && $shopCc != $customerCc
                    && $this->configHelper->isEuCountry($customerCc)
                ) {
                    $this->logger->customLog("Valid EU Group.");
                    return $this->configHelper->getTargetGroupEu();

                //Valid Domestic
                } elseif ($vatdata['vat_is_valid'] == true
                          && $vatdata['vat_request_success'] == true
                          && $shopCc == $customerCc
                          && $this->configHelper->isEuCountry($customerCc)
                ) {
                    $this->logger->customLog("Valid Domestic Group.");
                    return $this->configHelper->getTargetGroupDomestic();

                //Invalid Number
                } elseif ($vatdata['vat_is_valid'] == false
                          && $vatdata['vat_request_success'] == true
                ) {
                    $this->logger->customLog("Invalid Number Group.");
                    return $this->configHelper->getTargetGroupInvalid();

                //Request fail
                } elseif ($vatdata['vat_request_success'] == false) {
                    $this->logger->customLog("Technical Error Group.");
                    return $this->configHelper->getTargetGroupErrors();

                //non-EU
                } else {
                    if (!$this->configHelper->isEuCountry($customerCc)) {
                        $this->logger->customLog("NON-Europe Group.");
                        return $this->configHelper->getTargetGroupOutsideEu();
                    }
                }
            } else {// No validation data, try to identify country outside EU
                if (!$this->configHelper->isEuCountry($customerCc)) {
                    $this->logger->customLog("NON-Europe Group");
                    return $this->configHelper->getTargetGroupOutsideEu();
                }
            }
            $this->logger->customLog("Default Group.");
            return $this->configHelper->getTargetGroupDefault();
        } catch (\Exception $e) {
            $this->logger->critical($e);
            $this->logger->customLog("Default Group :x");
            return $this->configHelper->getTargetGroupDefault();
        }
    }
}
